---
title: "Tutorial de Shiny"
output: 
  prettydoc::html_pretty:
  theme: karen
  toc: true
  highligh: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning  = TRUE)
knitr::opts_chunk$set(message  = TRUE)
```

## Começando

Para trabalharmos com o shiny é  necessário o pacote `shiny`.

Após carregada a biblioteca, um dos modos mais simples para a criação de um aplicativo em shiny é criando um novo dirretorio e dentro dele um script, com as informações de como seu arquivo deve se comportar e seu formato.Para esse exemplo veja o script **exemlos/exemplo 1** no repositório  Git ***.
Veja que o código faz quatro coisas :

- Chama a biblioteca do pacote
- Define uma página HTML, contendo as palavras "hello,world "
- Especifica o comporatmento do app por uma função `server`. Que no momento ainda não faz nada
- Executa `shinyApp(ui,server)` que monta nossa aplicativo shiny , dado a interface (HTML) e a função server. 

Observação: Enquanto o aplicativo shiny roda, o R se torna ocupado , ou seja. Não
podemos usar o console para rodar um código. 

Na pasta **exemplo2** vemos o mesmo aplicativo com uma página HTML  mais complexa , os  novos elementos nela são:

 - `fluidPage()`: Uma função de layout básica..
 - `selectInput()`: É uma função de escolha de input , nesse caso é uma escolha por categorias dadas pelos datasets no pacote "datasets" .
 - `verbatimTextOutput()`: É uma função de controle de output. Que nesse caso mostra códigos.
 - ` tableOutput() `:É uma função de controle de output. Que nesse caso mostra uma tabela. 
 
No exemplo 3 , adicionamos a função server algumas coisas que ela deve fazer. Veja que anteriormente em `fluid_page`, definimos através das funções `verbetimTextOut("summary")` e `tableOutput("table")` o formato que essas variavéis , `summary` e `table ` seriam imprimidos, a primeira em código e a segunda em tabela. E agora na função server através de
`
```
server <- function(input, output, session) {
  output$summary <- renderPrint({
  })
 
 output$table <- renderTable({
  })
}

```

Etamos usando as indentificações criadas para renderizar no (HTML) final o formato desejado . 

Além dessas definições de reenderização usando a função`get(input$dataset,  "package:datasets")` obtemos o input que foi fornecido anteriormente. O resto do código é simplismente as funções a serem aplicadas sobre o input.

Assim vemos que nosso código se torna reativo, ou seja teremos um resultado diferente para cada valor que o usuário selecionar .

Terminado no **exemplo 4** vemos uma forma de não repetir o código `dataset <- get(input$dataset, "package:datasets")`, usando o **expressões reativas**, ela básicamente é como uma função que em sua primeira chamada lê o input e armazena o que foi passado e salva em um elemento .
Podemos simplificar o código anterior pela expressão reativa.

```
server <- function(input, output, session) {
  # Create a reactive expression
  dataset <- reactive({
    get(input$dataset, "package:datasets")
  })

  output$summary <- renderPrint({
    # Use a reactive expression by calling it like a function
    summary(dataset())
  })
  
  output$table <- renderTable({
    dataset()
  })
}

```

Agora a expressão `dataset()` é um recipiente para nosso input .

Concluimos o capítulo inicial aonde é possível através desse aplicativo simples. Entender as partes básicas de uma aplicação Shiny.
.





 

 


